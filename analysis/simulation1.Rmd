---
  title: "mixopt"
  output:
    html_document:
      toc: false
---

In this documentation, we will analyze convergence of SQP algorithm.

```{r}
getwd();
rjulia::julia_init();
rjulia::r2j(getwd(),"working_directory");
rjulia::julia_void_eval('cd(working_directory[1])');
rjulia::julia_void_eval('include("sqp.jl")');
```

```{r}
get_sample = function(n,seed=2017){
  set.seed(seed)
  n1 = floor(n/2)
  z = c(rnorm(n1),4*rt(n-n1,df=6))
  z = z[order(abs(z))]
  return(z)
}

get_matrix_lik = function(z,m = 1.1){
  data = ashr::set_data(z,1)
  grid = ashr:::autoselect.mixsd(data, mult=m, mode=0, mixcompdist="normal", grange=c(-Inf,Inf))
  grid = c(0,grid)
  k = length(grid)
  g  = ashr::normalmix(rep(1/k,k),rep(0,k),grid)
  llik <- t(ashr:::log_comp_dens_conv.normalmix(g,data))
  L = llik - apply(llik, 1, max)
  L = exp(L)
  return(L)
}
```

We sample from the distribution $z\sim 0.5 N(0,1) + 0.5 t_{6,4}$.

```{r}
eval_f = function(L,x){
  return(-sum(log(L %*% x)) / dim(L)[2])
}
sim_data = function(n, m){
  z = get_sample(n);
  matrix_lik = get_matrix_lik(z, m);
  return(matrix_lik)
}
sim_ip = function(matrix_lik){
  n = dim(matrix_lik)[1]; k = dim(matrix_lik)[2];
  t = system.time(res <- REBayes::KWDual(matrix_lik, rep(1,k), rep(1,n)/n))[3]
  min.f = 1E-8
  res$f[res$f < min.f] = 0
  return(list(x = res$f / sum(res$f), t = t))
}
sim_sqp = function(matrix_lik){
  rjulia::r2j(matrix_lik,"matrix_lik");
  t = system.time(rjulia::julia_void_eval('temp = sqp(matrix_lik,1e-8,1e-8,1e-3)'))[3];
  x = rjulia::j2r("temp[1]")
  x = x / sum(x)
  return(list(x = x, t = t))
}
```

We pass the likelihood matrix to Julia and then run the code.

```{r}
sim_comptime = function(n, m){
  # compute likelihood matrix
  temp = system.time(matrix_lik <- sim_data(n, m))[3];
  # run ip - REBayes
  ip = sim_ip(matrix_lik)
  # run sqp
  sqp = sim_sqp(matrix_lik)
  f1 = eval_f(matrix_lik,ip$x)
  f2 = eval_f(matrix_lik,sqp$x)
  comp_time = c(temp,ip$t,sqp$t)
  names(comp_time) = c("L","IP","SQP")
  return(list(rel_diff = f2/f1 - 1, norm_diff = sum(abs(ip$x-sqp$x)), comp_time = comp_time))
}
```

Test if it works well

```{r}
sim_comptime(10000,1.1)
```


```{r}
iter = 10
n_range = 1000 * 2^(1:iter)
m1 = 1.1
f1 = rep(0,iter)
t1 = matrix(0,3,iter)
for (i in 1:iter){
  temp = sim_comptime(n_range[i], m1)
  f1[i] = temp$rel_diff
  t1[,i] = temp$comp_time
}
```

```{r}
m2 = 1.2
f2 = rep(0,iter)
t2 = matrix(0,3,iter)
for (i in 1:iter){
  temp = sim_comptime(n_range[i], m2)
  f2[i] = temp$rel_diff
  t2[,i] = temp$comp_time
}
```

```{r}
m3 = 1.05
f3 = rep(0,iter)
t3 = matrix(0,3,iter)
for (i in 1:iter){
  temp = sim_comptime(n_range[i], m3)
  f3[i] = temp$rel_diff
  t3[,i] = temp$comp_time
}
```

```{r}
m4 = 1.3
f4 = rep(0,iter)
t4 = matrix(0,3,iter)
for (i in 1:iter){
  temp = sim_comptime(n_range[i], m3)
  f4[i] = temp$rel_diff
  t4[,i] = temp$comp_time
}
```

```{r}
p <- ggplot(data.frame(x = log2(n_range),y = log2(t2[2,])),aes(x = x,y = y)) +
  geom_line(color = "salmon",size = 1.5) +
  geom_line(data = data.frame(x = log2(n_range),y = log2(t2[3,])),color = "salmon",
            linetype = "dotted",size = 1.5) +
  geom_line(data = data.frame(x = log2(n_range),y = log2(t3[2,])),color = "darkblue",
            size = 1.5) +
  geom_line(data = data.frame(x = log2(n_range),y = log2(t3[3,])),color = "darkblue",
            linetype = "dotted",size = 1.5) +
  geom_line(data = data.frame(x = log2(n_range),y = log2(t1[2,])),color = "orange",
            size = 1.5) +
  geom_line(data = data.frame(x = log2(n_range),y = log2(t1[3,])),color = "orange",
            linetype = "dotted",size = 1.5)
p
```